
\documentclass[a4paper, 12 pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[slovene]{babel}
\usepackage{lmodern}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
%\usepackage{units}
%\usepackage{eurosym}
%\usepackage{pdfpages}
%\usepackage{comment}
%\usepackage{enumerate}
%\usepackage{mathtools}



\title{Wiener inverse interval problem}
\author{Tjaša Renko \\ Darjan Pavšič}

\begin{document}
\maketitle

\section{Predstavitev problema}

\textit{Opis problema}

P1
Za fiksno število vozlišč n in drevo T je T_{n+1} množica vseh dreves na n+1 vozliščih, dobljena iz T z dodajanjem lista enemu iz vozlišč T, W(T_{n+1}) pa množica vrednosti wienerjevih indeksov dreves iz T_{n+1}. Poiskati želimo tako drevo T na n vozliščih, da bo moč množice W(T_{n+1}) čim manjša/večja.

P2
Za fiksno število vozlišč n iščemo drevo T z največjim premerom, da bo veljalo; obstajata u in w iz T, da list u pripet na v in w tak, da z odstranitvijo povezave uv in dodajanjem uw spremenimo vrednost indeksa za 1.

\section{Opis dela}

Za izvedbo naloge sva se odločila za programski jezik \textit{Python}, za lažje delo z grafi pa sva si pomagala s knjižnico \texttt{networkx}.
\textit{Tukaj sledi še KRATEK opis, kaj koda dela}.

P1
Za začetek sva potrebovala ustrezne grafe. Ker je izomorfnih dreves na n vozliščih preveč za preverjanje vseh, sva generirala par naključnih s pomočjo Kruskalovega algoritma. Poskusila sva tudi z vgrajenimi funkcijami, a so se izkazale za neuporabne, saj so vračale med seboj preveč podobna drevesa. Za časovno optimalno računanje wienerjevih indeksov sva najprej shranila dolžine najkrajših poti med vsakima točkama grafa. Tako sva potem lahko izračunala indeks vsakega posameznega novega drevesa v linernem času; potrebovala sva namreč le vsoto poti iz vozlišča, ki sva mu dodala list, vsoto vseh poti ter število vozlišč; vse te podatke pa sva že imela. Ko sva dobila podatke za na začetku generirana drevesa, sva na vsakem izvedla algoritem za iskanje lokalnih ekstremov v okolici grafa, in sicer vrsto metahevristike z angleškim imenom simulated annealing. Ta na vsakem koraku preveri stanje sosednjega grafa in se s padajočo verjetnostjo odloča, ali se bo vanj preselila, hkrati pa shranjuje najboljši rezultat do sedaj. Imela sva težave z definiranjem sosednjega drevesa, zato nameravava preiskusiti par načinov in izbrati ugodnega. Pri prvotnem sva odstranila naključno povezavo, nato pa povezave dodajala in odstranjala, dokler nisva dobila povezanega drevesa, kar se ni izkazalo za učinkovit postopek. Po končanem algoritmu simulated annealing je bilo treba samo še preveriti najboljšega izmed vseh rezultatov, ki jih je podala omenjena metahevristika. Razmišljala sva, da bi na začetku generirala večje število grafov in zadnji algoritem izvedla le na tistih, ki dajejo boljše rezultate, kar bi bilo hitreje. To bo dobro natanko takrat, ko bodo imeli sosednji grafi podobno moč množice W(T_{n+1}), torej želiva to doseči pri novem definiranju sosedov. Ko bova zoptimizirala postopke in dobila zadostno število iskanih dreves, se bova morala spomniti še, kako jih primerjati.
...bom še končala

P2
...sledi


A lahko združiva opis dela in načrt? Mal se prekrivata in sem že mal napisala zraven

\section{Načrt za nadaljnje delo}

Ko bova na podlagi dovolj velikega vzorca dreves videla, katera so za najina problema najbolj ugodna, bova s pomočjo genetskega algoritma postopoma izbirala le tista najugodnejša in jih na vsakem koraku križala ali modificirala. Ta postopek bova ponavljala, dokler bo postopek na posameznem koraku še vračal ugodnejša drevesa.



\end{document}
